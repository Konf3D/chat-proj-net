// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_5fservice_2eproto;
namespace net_service {
class CredentialsSignIn;
struct CredentialsSignInDefaultTypeInternal;
extern CredentialsSignInDefaultTypeInternal _CredentialsSignIn_default_instance_;
class CredentialsSignUp;
struct CredentialsSignUpDefaultTypeInternal;
extern CredentialsSignUpDefaultTypeInternal _CredentialsSignUp_default_instance_;
class MsgPos;
struct MsgPosDefaultTypeInternal;
extern MsgPosDefaultTypeInternal _MsgPos_default_instance_;
class PrivateMessageLoad;
struct PrivateMessageLoadDefaultTypeInternal;
extern PrivateMessageLoadDefaultTypeInternal _PrivateMessageLoad_default_instance_;
class PrivateMessageSave;
struct PrivateMessageSaveDefaultTypeInternal;
extern PrivateMessageSaveDefaultTypeInternal _PrivateMessageSave_default_instance_;
class PublicMessageLoad;
struct PublicMessageLoadDefaultTypeInternal;
extern PublicMessageLoadDefaultTypeInternal _PublicMessageLoad_default_instance_;
class PublicMessageSave;
struct PublicMessageSaveDefaultTypeInternal;
extern PublicMessageSaveDefaultTypeInternal _PublicMessageSave_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
}  // namespace net_service
PROTOBUF_NAMESPACE_OPEN
template<> ::net_service::CredentialsSignIn* Arena::CreateMaybeMessage<::net_service::CredentialsSignIn>(Arena*);
template<> ::net_service::CredentialsSignUp* Arena::CreateMaybeMessage<::net_service::CredentialsSignUp>(Arena*);
template<> ::net_service::MsgPos* Arena::CreateMaybeMessage<::net_service::MsgPos>(Arena*);
template<> ::net_service::PrivateMessageLoad* Arena::CreateMaybeMessage<::net_service::PrivateMessageLoad>(Arena*);
template<> ::net_service::PrivateMessageSave* Arena::CreateMaybeMessage<::net_service::PrivateMessageSave>(Arena*);
template<> ::net_service::PublicMessageLoad* Arena::CreateMaybeMessage<::net_service::PublicMessageLoad>(Arena*);
template<> ::net_service::PublicMessageSave* Arena::CreateMaybeMessage<::net_service::PublicMessageSave>(Arena*);
template<> ::net_service::Token* Arena::CreateMaybeMessage<::net_service::Token>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace net_service {

// ===================================================================

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // bool result = 2;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // @@protoc_insertion_point(class_scope:net_service.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    bool result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CredentialsSignIn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.CredentialsSignIn) */ {
 public:
  inline CredentialsSignIn() : CredentialsSignIn(nullptr) {}
  ~CredentialsSignIn() override;
  explicit PROTOBUF_CONSTEXPR CredentialsSignIn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CredentialsSignIn(const CredentialsSignIn& from);
  CredentialsSignIn(CredentialsSignIn&& from) noexcept
    : CredentialsSignIn() {
    *this = ::std::move(from);
  }

  inline CredentialsSignIn& operator=(const CredentialsSignIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CredentialsSignIn& operator=(CredentialsSignIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CredentialsSignIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CredentialsSignIn* internal_default_instance() {
    return reinterpret_cast<const CredentialsSignIn*>(
               &_CredentialsSignIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CredentialsSignIn& a, CredentialsSignIn& b) {
    a.Swap(&b);
  }
  inline void Swap(CredentialsSignIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CredentialsSignIn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CredentialsSignIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CredentialsSignIn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CredentialsSignIn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CredentialsSignIn& from) {
    CredentialsSignIn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CredentialsSignIn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.CredentialsSignIn";
  }
  protected:
  explicit CredentialsSignIn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
    kHashFieldNumber = 2,
  };
  // string login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:net_service.CredentialsSignIn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CredentialsSignUp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.CredentialsSignUp) */ {
 public:
  inline CredentialsSignUp() : CredentialsSignUp(nullptr) {}
  ~CredentialsSignUp() override;
  explicit PROTOBUF_CONSTEXPR CredentialsSignUp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CredentialsSignUp(const CredentialsSignUp& from);
  CredentialsSignUp(CredentialsSignUp&& from) noexcept
    : CredentialsSignUp() {
    *this = ::std::move(from);
  }

  inline CredentialsSignUp& operator=(const CredentialsSignUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CredentialsSignUp& operator=(CredentialsSignUp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CredentialsSignUp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CredentialsSignUp* internal_default_instance() {
    return reinterpret_cast<const CredentialsSignUp*>(
               &_CredentialsSignUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CredentialsSignUp& a, CredentialsSignUp& b) {
    a.Swap(&b);
  }
  inline void Swap(CredentialsSignUp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CredentialsSignUp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CredentialsSignUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CredentialsSignUp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CredentialsSignUp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CredentialsSignUp& from) {
    CredentialsSignUp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CredentialsSignUp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.CredentialsSignUp";
  }
  protected:
  explicit CredentialsSignUp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kHashFieldNumber = 3,
  };
  // string login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string hash = 3;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:net_service.CredentialsSignUp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class MsgPos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.MsgPos) */ {
 public:
  inline MsgPos() : MsgPos(nullptr) {}
  ~MsgPos() override;
  explicit PROTOBUF_CONSTEXPR MsgPos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgPos(const MsgPos& from);
  MsgPos(MsgPos&& from) noexcept
    : MsgPos() {
    *this = ::std::move(from);
  }

  inline MsgPos& operator=(const MsgPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgPos& operator=(MsgPos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgPos& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgPos* internal_default_instance() {
    return reinterpret_cast<const MsgPos*>(
               &_MsgPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgPos& a, MsgPos& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgPos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgPos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgPos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgPos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgPos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MsgPos& from) {
    MsgPos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgPos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.MsgPos";
  }
  protected:
  explicit MsgPos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPosFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 pos = 2;
  void clear_pos();
  int64_t pos() const;
  void set_pos(int64_t value);
  private:
  int64_t _internal_pos() const;
  void _internal_set_pos(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:net_service.MsgPos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int64_t pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublicMessageSave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.PublicMessageSave) */ {
 public:
  inline PublicMessageSave() : PublicMessageSave(nullptr) {}
  ~PublicMessageSave() override;
  explicit PROTOBUF_CONSTEXPR PublicMessageSave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicMessageSave(const PublicMessageSave& from);
  PublicMessageSave(PublicMessageSave&& from) noexcept
    : PublicMessageSave() {
    *this = ::std::move(from);
  }

  inline PublicMessageSave& operator=(const PublicMessageSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicMessageSave& operator=(PublicMessageSave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicMessageSave& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicMessageSave* internal_default_instance() {
    return reinterpret_cast<const PublicMessageSave*>(
               &_PublicMessageSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PublicMessageSave& a, PublicMessageSave& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicMessageSave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicMessageSave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicMessageSave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicMessageSave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicMessageSave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublicMessageSave& from) {
    PublicMessageSave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicMessageSave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.PublicMessageSave";
  }
  protected:
  explicit PublicMessageSave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContentFieldNumber = 2,
    kTokenFieldNumber = 3,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string token = 3;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:net_service.PublicMessageSave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublicMessageLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.PublicMessageLoad) */ {
 public:
  inline PublicMessageLoad() : PublicMessageLoad(nullptr) {}
  ~PublicMessageLoad() override;
  explicit PROTOBUF_CONSTEXPR PublicMessageLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublicMessageLoad(const PublicMessageLoad& from);
  PublicMessageLoad(PublicMessageLoad&& from) noexcept
    : PublicMessageLoad() {
    *this = ::std::move(from);
  }

  inline PublicMessageLoad& operator=(const PublicMessageLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicMessageLoad& operator=(PublicMessageLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublicMessageLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublicMessageLoad* internal_default_instance() {
    return reinterpret_cast<const PublicMessageLoad*>(
               &_PublicMessageLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PublicMessageLoad& a, PublicMessageLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicMessageLoad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicMessageLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublicMessageLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublicMessageLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublicMessageLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublicMessageLoad& from) {
    PublicMessageLoad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicMessageLoad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.PublicMessageLoad";
  }
  protected:
  explicit PublicMessageLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContentFieldNumber = 2,
    kTokenFieldNumber = 4,
    kPositionFieldNumber = 3,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string token = 4;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 position = 3;
  void clear_position();
  int64_t position() const;
  void set_position(int64_t value);
  private:
  int64_t _internal_position() const;
  void _internal_set_position(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:net_service.PublicMessageLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int64_t position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PrivateMessageSave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.PrivateMessageSave) */ {
 public:
  inline PrivateMessageSave() : PrivateMessageSave(nullptr) {}
  ~PrivateMessageSave() override;
  explicit PROTOBUF_CONSTEXPR PrivateMessageSave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateMessageSave(const PrivateMessageSave& from);
  PrivateMessageSave(PrivateMessageSave&& from) noexcept
    : PrivateMessageSave() {
    *this = ::std::move(from);
  }

  inline PrivateMessageSave& operator=(const PrivateMessageSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateMessageSave& operator=(PrivateMessageSave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateMessageSave& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateMessageSave* internal_default_instance() {
    return reinterpret_cast<const PrivateMessageSave*>(
               &_PrivateMessageSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PrivateMessageSave& a, PrivateMessageSave& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateMessageSave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateMessageSave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateMessageSave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateMessageSave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateMessageSave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivateMessageSave& from) {
    PrivateMessageSave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateMessageSave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.PrivateMessageSave";
  }
  protected:
  explicit PrivateMessageSave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContentFieldNumber = 2,
    kRecieverFieldNumber = 3,
    kTokenFieldNumber = 4,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string reciever = 3;
  void clear_reciever();
  const std::string& reciever() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reciever(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reciever();
  PROTOBUF_NODISCARD std::string* release_reciever();
  void set_allocated_reciever(std::string* reciever);
  private:
  const std::string& _internal_reciever() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reciever(const std::string& value);
  std::string* _internal_mutable_reciever();
  public:

  // string token = 4;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:net_service.PrivateMessageSave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reciever_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PrivateMessageLoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:net_service.PrivateMessageLoad) */ {
 public:
  inline PrivateMessageLoad() : PrivateMessageLoad(nullptr) {}
  ~PrivateMessageLoad() override;
  explicit PROTOBUF_CONSTEXPR PrivateMessageLoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateMessageLoad(const PrivateMessageLoad& from);
  PrivateMessageLoad(PrivateMessageLoad&& from) noexcept
    : PrivateMessageLoad() {
    *this = ::std::move(from);
  }

  inline PrivateMessageLoad& operator=(const PrivateMessageLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateMessageLoad& operator=(PrivateMessageLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateMessageLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateMessageLoad* internal_default_instance() {
    return reinterpret_cast<const PrivateMessageLoad*>(
               &_PrivateMessageLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PrivateMessageLoad& a, PrivateMessageLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateMessageLoad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateMessageLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateMessageLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateMessageLoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateMessageLoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivateMessageLoad& from) {
    PrivateMessageLoad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateMessageLoad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "net_service.PrivateMessageLoad";
  }
  protected:
  explicit PrivateMessageLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderFieldNumber = 1,
    kContentFieldNumber = 2,
    kRecieverFieldNumber = 3,
    kTokenFieldNumber = 5,
    kPositionFieldNumber = 4,
  };
  // string sender = 1;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string reciever = 3;
  void clear_reciever();
  const std::string& reciever() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reciever(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reciever();
  PROTOBUF_NODISCARD std::string* release_reciever();
  void set_allocated_reciever(std::string* reciever);
  private:
  const std::string& _internal_reciever() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reciever(const std::string& value);
  std::string* _internal_mutable_reciever();
  public:

  // string token = 5;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 position = 4;
  void clear_position();
  int64_t position() const;
  void set_position(int64_t value);
  private:
  int64_t _internal_position() const;
  void _internal_set_position(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:net_service.PrivateMessageLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reciever_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int64_t position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Token

// string token = 1;
inline void Token::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& Token::token() const {
  // @@protoc_insertion_point(field_get:net_service.Token.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.Token.token)
}
inline std::string* Token::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.Token.token)
  return _s;
}
inline const std::string& Token::_internal_token() const {
  return _impl_.token_.Get();
}
inline void Token::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_token() {
  // @@protoc_insertion_point(field_release:net_service.Token.token)
  return _impl_.token_.Release();
}
inline void Token::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.Token.token)
}

// bool result = 2;
inline void Token::clear_result() {
  _impl_.result_ = false;
}
inline bool Token::_internal_result() const {
  return _impl_.result_;
}
inline bool Token::result() const {
  // @@protoc_insertion_point(field_get:net_service.Token.result)
  return _internal_result();
}
inline void Token::_internal_set_result(bool value) {
  
  _impl_.result_ = value;
}
inline void Token::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:net_service.Token.result)
}

// -------------------------------------------------------------------

// CredentialsSignIn

// string login = 1;
inline void CredentialsSignIn::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& CredentialsSignIn::login() const {
  // @@protoc_insertion_point(field_get:net_service.CredentialsSignIn.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialsSignIn::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.CredentialsSignIn.login)
}
inline std::string* CredentialsSignIn::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:net_service.CredentialsSignIn.login)
  return _s;
}
inline const std::string& CredentialsSignIn::_internal_login() const {
  return _impl_.login_.Get();
}
inline void CredentialsSignIn::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialsSignIn::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialsSignIn::release_login() {
  // @@protoc_insertion_point(field_release:net_service.CredentialsSignIn.login)
  return _impl_.login_.Release();
}
inline void CredentialsSignIn::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.CredentialsSignIn.login)
}

// string hash = 2;
inline void CredentialsSignIn::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CredentialsSignIn::hash() const {
  // @@protoc_insertion_point(field_get:net_service.CredentialsSignIn.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialsSignIn::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.CredentialsSignIn.hash)
}
inline std::string* CredentialsSignIn::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:net_service.CredentialsSignIn.hash)
  return _s;
}
inline const std::string& CredentialsSignIn::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CredentialsSignIn::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialsSignIn::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialsSignIn::release_hash() {
  // @@protoc_insertion_point(field_release:net_service.CredentialsSignIn.hash)
  return _impl_.hash_.Release();
}
inline void CredentialsSignIn::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.CredentialsSignIn.hash)
}

// -------------------------------------------------------------------

// CredentialsSignUp

// string login = 1;
inline void CredentialsSignUp::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& CredentialsSignUp::login() const {
  // @@protoc_insertion_point(field_get:net_service.CredentialsSignUp.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialsSignUp::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.CredentialsSignUp.login)
}
inline std::string* CredentialsSignUp::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:net_service.CredentialsSignUp.login)
  return _s;
}
inline const std::string& CredentialsSignUp::_internal_login() const {
  return _impl_.login_.Get();
}
inline void CredentialsSignUp::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::release_login() {
  // @@protoc_insertion_point(field_release:net_service.CredentialsSignUp.login)
  return _impl_.login_.Release();
}
inline void CredentialsSignUp::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.CredentialsSignUp.login)
}

// string username = 2;
inline void CredentialsSignUp::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CredentialsSignUp::username() const {
  // @@protoc_insertion_point(field_get:net_service.CredentialsSignUp.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialsSignUp::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.CredentialsSignUp.username)
}
inline std::string* CredentialsSignUp::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:net_service.CredentialsSignUp.username)
  return _s;
}
inline const std::string& CredentialsSignUp::_internal_username() const {
  return _impl_.username_.Get();
}
inline void CredentialsSignUp::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::release_username() {
  // @@protoc_insertion_point(field_release:net_service.CredentialsSignUp.username)
  return _impl_.username_.Release();
}
inline void CredentialsSignUp::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.CredentialsSignUp.username)
}

// string hash = 3;
inline void CredentialsSignUp::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CredentialsSignUp::hash() const {
  // @@protoc_insertion_point(field_get:net_service.CredentialsSignUp.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialsSignUp::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.CredentialsSignUp.hash)
}
inline std::string* CredentialsSignUp::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:net_service.CredentialsSignUp.hash)
  return _s;
}
inline const std::string& CredentialsSignUp::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CredentialsSignUp::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialsSignUp::release_hash() {
  // @@protoc_insertion_point(field_release:net_service.CredentialsSignUp.hash)
  return _impl_.hash_.Release();
}
inline void CredentialsSignUp::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.CredentialsSignUp.hash)
}

// -------------------------------------------------------------------

// MsgPos

// string token = 1;
inline void MsgPos::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& MsgPos::token() const {
  // @@protoc_insertion_point(field_get:net_service.MsgPos.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgPos::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.MsgPos.token)
}
inline std::string* MsgPos::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.MsgPos.token)
  return _s;
}
inline const std::string& MsgPos::_internal_token() const {
  return _impl_.token_.Get();
}
inline void MsgPos::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgPos::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgPos::release_token() {
  // @@protoc_insertion_point(field_release:net_service.MsgPos.token)
  return _impl_.token_.Release();
}
inline void MsgPos::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.MsgPos.token)
}

// int64 pos = 2;
inline void MsgPos::clear_pos() {
  _impl_.pos_ = int64_t{0};
}
inline int64_t MsgPos::_internal_pos() const {
  return _impl_.pos_;
}
inline int64_t MsgPos::pos() const {
  // @@protoc_insertion_point(field_get:net_service.MsgPos.pos)
  return _internal_pos();
}
inline void MsgPos::_internal_set_pos(int64_t value) {
  
  _impl_.pos_ = value;
}
inline void MsgPos::set_pos(int64_t value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:net_service.MsgPos.pos)
}

// -------------------------------------------------------------------

// PublicMessageSave

// string sender = 1;
inline void PublicMessageSave::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PublicMessageSave::sender() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageSave.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageSave::set_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageSave.sender)
}
inline std::string* PublicMessageSave::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageSave.sender)
  return _s;
}
inline const std::string& PublicMessageSave::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PublicMessageSave::_internal_set_sender(const std::string& value) {
  
  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageSave::_internal_mutable_sender() {
  
  return _impl_.sender_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageSave::release_sender() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageSave.sender)
  return _impl_.sender_.Release();
}
inline void PublicMessageSave::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  _impl_.sender_.SetAllocated(sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageSave.sender)
}

// string content = 2;
inline void PublicMessageSave::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PublicMessageSave::content() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageSave.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageSave::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageSave.content)
}
inline std::string* PublicMessageSave::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageSave.content)
  return _s;
}
inline const std::string& PublicMessageSave::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PublicMessageSave::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageSave::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageSave::release_content() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageSave.content)
  return _impl_.content_.Release();
}
inline void PublicMessageSave::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageSave.content)
}

// string token = 3;
inline void PublicMessageSave::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PublicMessageSave::token() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageSave.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageSave::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageSave.token)
}
inline std::string* PublicMessageSave::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageSave.token)
  return _s;
}
inline const std::string& PublicMessageSave::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PublicMessageSave::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageSave::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageSave::release_token() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageSave.token)
  return _impl_.token_.Release();
}
inline void PublicMessageSave::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageSave.token)
}

// -------------------------------------------------------------------

// PublicMessageLoad

// string sender = 1;
inline void PublicMessageLoad::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PublicMessageLoad::sender() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageLoad.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageLoad::set_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageLoad.sender)
}
inline std::string* PublicMessageLoad::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageLoad.sender)
  return _s;
}
inline const std::string& PublicMessageLoad::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PublicMessageLoad::_internal_set_sender(const std::string& value) {
  
  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::_internal_mutable_sender() {
  
  return _impl_.sender_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::release_sender() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageLoad.sender)
  return _impl_.sender_.Release();
}
inline void PublicMessageLoad::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  _impl_.sender_.SetAllocated(sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageLoad.sender)
}

// string content = 2;
inline void PublicMessageLoad::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PublicMessageLoad::content() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageLoad.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageLoad::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageLoad.content)
}
inline std::string* PublicMessageLoad::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageLoad.content)
  return _s;
}
inline const std::string& PublicMessageLoad::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PublicMessageLoad::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::release_content() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageLoad.content)
  return _impl_.content_.Release();
}
inline void PublicMessageLoad::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageLoad.content)
}

// int64 position = 3;
inline void PublicMessageLoad::clear_position() {
  _impl_.position_ = int64_t{0};
}
inline int64_t PublicMessageLoad::_internal_position() const {
  return _impl_.position_;
}
inline int64_t PublicMessageLoad::position() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageLoad.position)
  return _internal_position();
}
inline void PublicMessageLoad::_internal_set_position(int64_t value) {
  
  _impl_.position_ = value;
}
inline void PublicMessageLoad::set_position(int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:net_service.PublicMessageLoad.position)
}

// string token = 4;
inline void PublicMessageLoad::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PublicMessageLoad::token() const {
  // @@protoc_insertion_point(field_get:net_service.PublicMessageLoad.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublicMessageLoad::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PublicMessageLoad.token)
}
inline std::string* PublicMessageLoad::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.PublicMessageLoad.token)
  return _s;
}
inline const std::string& PublicMessageLoad::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PublicMessageLoad::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PublicMessageLoad::release_token() {
  // @@protoc_insertion_point(field_release:net_service.PublicMessageLoad.token)
  return _impl_.token_.Release();
}
inline void PublicMessageLoad::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PublicMessageLoad.token)
}

// -------------------------------------------------------------------

// PrivateMessageSave

// string sender = 1;
inline void PrivateMessageSave::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PrivateMessageSave::sender() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageSave.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageSave::set_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageSave.sender)
}
inline std::string* PrivateMessageSave::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageSave.sender)
  return _s;
}
inline const std::string& PrivateMessageSave::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PrivateMessageSave::_internal_set_sender(const std::string& value) {
  
  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::_internal_mutable_sender() {
  
  return _impl_.sender_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::release_sender() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageSave.sender)
  return _impl_.sender_.Release();
}
inline void PrivateMessageSave::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  _impl_.sender_.SetAllocated(sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageSave.sender)
}

// string content = 2;
inline void PrivateMessageSave::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PrivateMessageSave::content() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageSave.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageSave::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageSave.content)
}
inline std::string* PrivateMessageSave::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageSave.content)
  return _s;
}
inline const std::string& PrivateMessageSave::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PrivateMessageSave::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::release_content() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageSave.content)
  return _impl_.content_.Release();
}
inline void PrivateMessageSave::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageSave.content)
}

// string reciever = 3;
inline void PrivateMessageSave::clear_reciever() {
  _impl_.reciever_.ClearToEmpty();
}
inline const std::string& PrivateMessageSave::reciever() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageSave.reciever)
  return _internal_reciever();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageSave::set_reciever(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reciever_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageSave.reciever)
}
inline std::string* PrivateMessageSave::mutable_reciever() {
  std::string* _s = _internal_mutable_reciever();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageSave.reciever)
  return _s;
}
inline const std::string& PrivateMessageSave::_internal_reciever() const {
  return _impl_.reciever_.Get();
}
inline void PrivateMessageSave::_internal_set_reciever(const std::string& value) {
  
  _impl_.reciever_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::_internal_mutable_reciever() {
  
  return _impl_.reciever_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::release_reciever() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageSave.reciever)
  return _impl_.reciever_.Release();
}
inline void PrivateMessageSave::set_allocated_reciever(std::string* reciever) {
  if (reciever != nullptr) {
    
  } else {
    
  }
  _impl_.reciever_.SetAllocated(reciever, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reciever_.IsDefault()) {
    _impl_.reciever_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageSave.reciever)
}

// string token = 4;
inline void PrivateMessageSave::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PrivateMessageSave::token() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageSave.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageSave::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageSave.token)
}
inline std::string* PrivateMessageSave::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageSave.token)
  return _s;
}
inline const std::string& PrivateMessageSave::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PrivateMessageSave::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageSave::release_token() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageSave.token)
  return _impl_.token_.Release();
}
inline void PrivateMessageSave::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageSave.token)
}

// -------------------------------------------------------------------

// PrivateMessageLoad

// string sender = 1;
inline void PrivateMessageLoad::clear_sender() {
  _impl_.sender_.ClearToEmpty();
}
inline const std::string& PrivateMessageLoad::sender() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageLoad.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageLoad::set_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageLoad.sender)
}
inline std::string* PrivateMessageLoad::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageLoad.sender)
  return _s;
}
inline const std::string& PrivateMessageLoad::_internal_sender() const {
  return _impl_.sender_.Get();
}
inline void PrivateMessageLoad::_internal_set_sender(const std::string& value) {
  
  _impl_.sender_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::_internal_mutable_sender() {
  
  return _impl_.sender_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::release_sender() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageLoad.sender)
  return _impl_.sender_.Release();
}
inline void PrivateMessageLoad::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  _impl_.sender_.SetAllocated(sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_.IsDefault()) {
    _impl_.sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageLoad.sender)
}

// string content = 2;
inline void PrivateMessageLoad::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PrivateMessageLoad::content() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageLoad.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageLoad::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageLoad.content)
}
inline std::string* PrivateMessageLoad::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageLoad.content)
  return _s;
}
inline const std::string& PrivateMessageLoad::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PrivateMessageLoad::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::release_content() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageLoad.content)
  return _impl_.content_.Release();
}
inline void PrivateMessageLoad::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageLoad.content)
}

// string reciever = 3;
inline void PrivateMessageLoad::clear_reciever() {
  _impl_.reciever_.ClearToEmpty();
}
inline const std::string& PrivateMessageLoad::reciever() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageLoad.reciever)
  return _internal_reciever();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageLoad::set_reciever(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reciever_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageLoad.reciever)
}
inline std::string* PrivateMessageLoad::mutable_reciever() {
  std::string* _s = _internal_mutable_reciever();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageLoad.reciever)
  return _s;
}
inline const std::string& PrivateMessageLoad::_internal_reciever() const {
  return _impl_.reciever_.Get();
}
inline void PrivateMessageLoad::_internal_set_reciever(const std::string& value) {
  
  _impl_.reciever_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::_internal_mutable_reciever() {
  
  return _impl_.reciever_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::release_reciever() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageLoad.reciever)
  return _impl_.reciever_.Release();
}
inline void PrivateMessageLoad::set_allocated_reciever(std::string* reciever) {
  if (reciever != nullptr) {
    
  } else {
    
  }
  _impl_.reciever_.SetAllocated(reciever, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reciever_.IsDefault()) {
    _impl_.reciever_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageLoad.reciever)
}

// int64 position = 4;
inline void PrivateMessageLoad::clear_position() {
  _impl_.position_ = int64_t{0};
}
inline int64_t PrivateMessageLoad::_internal_position() const {
  return _impl_.position_;
}
inline int64_t PrivateMessageLoad::position() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageLoad.position)
  return _internal_position();
}
inline void PrivateMessageLoad::_internal_set_position(int64_t value) {
  
  _impl_.position_ = value;
}
inline void PrivateMessageLoad::set_position(int64_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageLoad.position)
}

// string token = 5;
inline void PrivateMessageLoad::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& PrivateMessageLoad::token() const {
  // @@protoc_insertion_point(field_get:net_service.PrivateMessageLoad.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateMessageLoad::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:net_service.PrivateMessageLoad.token)
}
inline std::string* PrivateMessageLoad::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:net_service.PrivateMessageLoad.token)
  return _s;
}
inline const std::string& PrivateMessageLoad::_internal_token() const {
  return _impl_.token_.Get();
}
inline void PrivateMessageLoad::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateMessageLoad::release_token() {
  // @@protoc_insertion_point(field_release:net_service.PrivateMessageLoad.token)
  return _impl_.token_.Release();
}
inline void PrivateMessageLoad::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:net_service.PrivateMessageLoad.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace net_service

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_5fservice_2eproto
